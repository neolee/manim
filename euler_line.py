# Generated by GitHub Copilot and GPT-5 Preview through prompts:
# 1. 使用manimgl库生成动画，表现出“任意三角形的重心、垂心、外心三点共线”这一定理（欧拉线）
# 2. 很好，现在增加动画展示，当三角形的顶点移动时，三心依然共线


from manimlib import *  # type: ignore
import numpy as np


def circumcenter(a: np.ndarray, b: np.ndarray, c: np.ndarray) -> np.ndarray:
	"""Return circumcenter O of triangle ABC (2D vectors with z=0)."""
	ax, ay = a[0], a[1]
	bx, by = b[0], b[1]
	cx, cy = c[0], c[1]
	d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))
	# Degenerate safeguard: if area ~ 0, just return origin to avoid crash
	if abs(d) < 1e-8:
		return np.array([0.0, 0.0, 0.0])
	ux = (
		(ax * ax + ay * ay) * (by - cy)
		+ (bx * bx + by * by) * (cy - ay)
		+ (cx * cx + cy * cy) * (ay - by)
	) / d
	uy = (
		(ax * ax + ay * ay) * (cx - bx)
		+ (bx * bx + by * by) * (ax - cx)
		+ (cx * cx + cy * cy) * (bx - ax)
	) / d
	return np.array([ux, uy, 0.0])


def unit(v: np.ndarray) -> np.ndarray:
	n = np.linalg.norm(v)
	return v / n if n > 1e-8 else v


def perp2d(v: np.ndarray) -> np.ndarray:
	"""Return a 90° CCW perpendicular vector to v (assumes z=0)."""
	return np.array([-v[1], v[0], 0.0])


class EulerLine(Scene):
	"""
	欧拉线演示：任意三角形的重心 G、外心 O、垂心 H 三点共线。

	- 使用两条中线、两条垂直平分线、两条高线来分别标示 G、O、H
	- 最后绘制欧拉线 OH，并高亮显示 G 在其上且满足 OG:GH = 1:2
	"""

	def construct(self):
		# 1) 任取一个不共线的三角形 ABC（动态顶点）
		A0 = np.array([-4.0, -1.0, 0.0])
		B0 = np.array([3.5, -2.0, 0.0])
		C0 = np.array([-0.5, 3.0, 0.0])

		A_dot = Dot(A0, color=WHITE)  # type: ignore
		B_dot = Dot(B0, color=WHITE)  # type: ignore
		C_dot = Dot(C0, color=WHITE)  # type: ignore
		verts = VGroup(A_dot, B_dot, C_dot)

		# 顶点标签随顶点移动
		label_A = Text("A", font_size=36)
		label_B = Text("B", font_size=36)
		label_C = Text("C", font_size=36)
		label_A.add_updater(lambda m: m.next_to(A_dot, DL, buff=0.15))
		label_B.add_updater(lambda m: m.next_to(B_dot, DR, buff=0.15))
		label_C.add_updater(lambda m: m.next_to(C_dot, UL, buff=0.15))
		labels = VGroup(label_A, label_B, label_C)

		# 便捷函数：当前顶点与三心
		def A(): return A_dot.get_center()
		def B(): return B_dot.get_center()
		def C(): return C_dot.get_center()
		def G(): return (A() + B() + C()) / 3  # type: ignore
		def O(): return circumcenter(A(), B(), C())  # type: ignore
		def H(): return 3 * G() - 2 * O()  # type: ignore

		# 动态三角形边
		triangle = always_redraw(lambda: Polygon(A(), B(), C(), color=WHITE, stroke_width=4))  # type: ignore

		self.play(ShowCreation(triangle), FadeIn(verts, scale=0.5))
		self.play(LaggedStart(*[FadeIn(m) for m in labels], lag_ratio=0.2))
		self.wait(0.5)

		# 2) 重心 G：两条中线 + G 点
		def midpoint(P, Q):
			return (P + Q) / 2

		median_c = always_redraw(lambda: Line(C(), midpoint(A(), B()), color=GOLD))  # type: ignore
		median_a = always_redraw(lambda: Line(A(), midpoint(B(), C()), color=GOLD))  # type: ignore
		G_dot = always_redraw(lambda: Dot(G(), color=YELLOW))  # type: ignore
		G_lab = always_redraw(lambda: Text("G", font_size=34, color=YELLOW).next_to(G_dot, UR, buff=0.12))

		self.play(ShowCreation(median_c), ShowCreation(median_a))
		self.play(FadeIn(G_dot, scale=0.6), FadeIn(G_lab))
		self.wait(0.5)

		# 3) 外心 O：两条垂直平分线 + 外接圆
		def perp_dir(u: np.ndarray) -> np.ndarray:
			return unit(perp2d(u))

		def long_line_through(point: np.ndarray, direction: np.ndarray, scale=8.0) -> Line:
			d = unit(direction)
			return Line(point - scale * d, point + scale * d)  # type: ignore

		pb_ab = always_redraw(lambda: long_line_through(midpoint(A(), B()), perp_dir(B() - A())).set_color(TEAL))  # type: ignore
		pb_bc = always_redraw(lambda: long_line_through(midpoint(B(), C()), perp_dir(C() - B())).set_color(TEAL))  # type: ignore
		O_dot = always_redraw(lambda: Dot(O(), color=BLUE))  # type: ignore
		O_lab = always_redraw(lambda: Text("O", font_size=34, color=BLUE).next_to(O_dot, UL, buff=0.12))
		circum = always_redraw(lambda: Circle(radius=float(np.linalg.norm(A() - O())), color=BLUE, stroke_width=2).move_to(O()))  # type: ignore

		self.play(ShowCreation(pb_ab), ShowCreation(pb_bc))
		self.play(FadeIn(O_dot, scale=0.6), FadeIn(O_lab))
		self.play(ShowCreation(circum))
		self.wait(0.5)

		# 4) 垂心 H：两条高线 + H 点
		alt_a = always_redraw(lambda: long_line_through(A(), perp_dir(C() - B())).set_color(RED))  # type: ignore
		alt_b = always_redraw(lambda: long_line_through(B(), perp_dir(C() - A())).set_color(RED))  # type: ignore
		H_dot = always_redraw(lambda: Dot(H(), color=MAROON_A))  # type: ignore
		H_lab = always_redraw(lambda: Text("H", font_size=34, color=MAROON_A).next_to(H_dot, RIGHT, buff=0.12))

		self.play(ShowCreation(alt_a), ShowCreation(alt_b))
		self.play(FadeIn(H_dot, scale=0.6), FadeIn(H_lab))
		self.wait(0.5)

		# 5) 欧拉线：过 O 与 H 的直线，且 G 落在其上
		euler_line = always_redraw(lambda: long_line_through(O(), H() - O(), scale=10).set_color(PURPLE))
		self.play(ShowCreation(euler_line))
		self.play(
			FlashAround(G_dot, color=YELLOW),
			FlashAround(O_dot, color=BLUE),
			FlashAround(H_dot, color=MAROON_A),
		)
		self.wait(0.5)

		# 6) 展示比例 OG:GH = 1:2（在欧拉线上打刻度）
		def ticks():
			u = (H() - O()) / 3
			n_perp = unit(perp2d(u))
			t1 = Line(G() - 0.15 * n_perp, G() + 0.15 * n_perp)
			t2 = t1.copy().shift(u)  # type: ignore
			return VGroup(t1, t2).set_color(PURPLE)

		tick_group = always_redraw(ticks)
		ratio_text = Text("OG : GH = 1 : 2", font_size=28, color=PURPLE)
		ratio_text.to_edge(DOWN)

		self.play(ShowCreation(tick_group))
		self.play(Write(ratio_text))
		self.wait(1)

		# 7) 动画演示：移动顶点，三心依然共线
		self.play(
			FadeOut(median_a), FadeOut(median_c), FadeOut(pb_ab), FadeOut(pb_bc),
			FadeOut(alt_a), FadeOut(alt_b), FadeOut(circum), FadeOut(tick_group),
			run_time=1.0
		)
		self.wait(0.2)

		# 序列移动顶点（三次），观察 G/O/H 与欧拉线实时更新
		self.play(
			A_dot.animate.move_to(A_dot.get_center() + 1.8 * RIGHT + 0.6 * UP),  # type: ignore
			run_time=2
		)
		self.play(
			B_dot.animate.move_to(B_dot.get_center() + 1.6 * LEFT + 1.1 * UP),  # type: ignore
			run_time=2
		)
		self.play(
			C_dot.animate.move_to(C_dot.get_center() + 2.4 * RIGHT + 0.9 * DOWN),  # type: ignore
			run_time=2
		)
		self.wait(1)

