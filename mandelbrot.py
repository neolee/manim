# Generated by Copilot and GPT-5 throught prompts:
# 编写程序绘制 Mandelbrot set，要求：
# 1. 可以用鼠标选择一个局部进行放大重绘；
# 2. 可以通过命令行参数选择不同的调色盘；
# 3. 可以通过命令行参数输出图像文件（PNG格式）；
# 4. 尽可能优化性能。


"""
Mandelbrot Set Viewer and Renderer

功能:
1) 鼠标框选局部进行放大重绘（交互式窗口）。
2) 通过命令行参数选择不同调色盘（palette）。
3) 通过命令行参数输出 PNG 图像（无 GUI）。
4) 尽可能优化性能（NumPy 向量化 + 分块渲染，平滑着色）。

用法示例：
  - 交互式查看：
      python mandelbrot.py --palette hsv --width 1000 --height 700 --max-iter 512
  - 直接渲染 PNG：
      python mandelbrot.py --output out.png --palette fire --width 1920 --height 1080 --max-iter 1000
  - 指定初始视图中心与缩放：
      python mandelbrot.py --center -0.75,0.0 --scale 3.0

注意：本脚本依赖 numpy 与 pillow。
"""

from __future__ import annotations

import argparse
import math
import sys
from dataclasses import dataclass
from typing import Callable, Tuple

try:
    import numpy as np
except Exception as e:
    print("缺少依赖 numpy，请先安装: pip install numpy", file=sys.stderr)
    raise

try:
    from PIL import Image
except Exception:
    print("缺少依赖 pillow，请先安装: pip install pillow", file=sys.stderr)
    raise


# -----------------------------
# 颜色映射（调色盘）
# -----------------------------
def _clamp01(x: np.ndarray) -> np.ndarray:
    return np.clip(x, 0.0, 1.0)


def _hsv_to_rgb(h: np.ndarray, s: np.ndarray, v: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """向量化 HSV->RGB，h,s,v ∈ [0,1]"""
    h = h * 6.0
    i = np.floor(h).astype(int)
    f = h - i
    p = v * (1.0 - s)
    q = v * (1.0 - s * f)
    t = v * (1.0 - s * (1.0 - f))

    i_mod = i % 6
    r = np.zeros_like(v)
    g = np.zeros_like(v)
    b = np.zeros_like(v)

    mask = i_mod == 0
    r[mask], g[mask], b[mask] = v[mask], t[mask], p[mask]
    mask = i_mod == 1
    r[mask], g[mask], b[mask] = q[mask], v[mask], p[mask]
    mask = i_mod == 2
    r[mask], g[mask], b[mask] = p[mask], v[mask], t[mask]
    mask = i_mod == 3
    r[mask], g[mask], b[mask] = p[mask], q[mask], v[mask]
    mask = i_mod == 4
    r[mask], g[mask], b[mask] = t[mask], p[mask], v[mask]
    mask = i_mod == 5
    r[mask], g[mask], b[mask] = v[mask], p[mask], q[mask]
    return r, g, b


def palette_hsv(x: np.ndarray) -> np.ndarray:
    """彩虹 HSV 调色。x ∈ [0,1]"""
    h = x
    s = np.ones_like(x)
    v = np.where(x > 0, 1.0, 0.0)
    r, g, b = _hsv_to_rgb(h, s, v)
    rgb = np.stack((_clamp01(r), _clamp01(g), _clamp01(b)), axis=-1)
    return (rgb * 255).astype(np.uint8)


def palette_fire(x: np.ndarray) -> np.ndarray:
    """火焰色，从黑->暗红->橙->黄->白"""
    x = _clamp01(x)
    r = np.clip(3.5 * x, 0, 1)
    g = np.clip(3.0 * (x - 0.3), 0, 1)
    b = np.clip(3.0 * (x - 0.6), 0, 1)
    rgb = np.stack((r, g, b), axis=-1) ** 1.2
    return (rgb * 255).astype(np.uint8)


def palette_ocean(x: np.ndarray) -> np.ndarray:
    """海洋色，从黑->蓝->青->白"""
    x = _clamp01(x)
    r = np.zeros_like(x)
    g = np.clip(1.5 * (x - 0.3), 0, 1)
    b = np.clip(2.5 * x, 0, 1)
    rgb = np.stack((r, g, b), axis=-1) ** 1.1
    return (rgb * 255).astype(np.uint8)


def palette_gray(x: np.ndarray) -> np.ndarray:
    x = _clamp01(x)
    rgb = np.stack((x, x, x), axis=-1)
    return (rgb * 255).astype(np.uint8)


PALETTES: dict[str, Callable[[np.ndarray], np.ndarray]] = {
    "hsv": palette_hsv,
    "fire": palette_fire,
    "ocean": palette_ocean,
    "gray": palette_gray,
    "grayscale": palette_gray,
}


# -----------------------------
# 曼德博集合计算（平滑着色 + 分块）
# -----------------------------
@dataclass
class Viewport:
    center: complex = complex(-0.75, 0.0)
    scale: float = 3.5  # 横向跨度（实轴宽度）

    def bounds(self, aspect: float) -> Tuple[float, float, float, float]:
        half_w = self.scale / 2.0
        half_h = half_w / aspect
        xmin = self.center.real - half_w
        xmax = self.center.real + half_w
        ymin = self.center.imag - half_h
        ymax = self.center.imag + half_h
        return xmin, xmax, ymin, ymax


def mandelbrot_escape_smooth(width: int, height: int, max_iter: int, viewport: Viewport,
                             chunk_rows: int = 256) -> Tuple[np.ndarray, np.ndarray]:
    """
    计算平滑着色值与掩码。
    返回：smooth_vals ∈ [0, +)，escaped_mask（True表示逃逸）。
    分块逐行，避免一次性创建过大数组。
    """
    aspect = width / height
    xmin, xmax, ymin, ymax = viewport.bounds(aspect)

    xs = np.linspace(xmin, xmax, width, dtype=np.float64)
    ys = np.linspace(ymin, ymax, height, dtype=np.float64)

    smooth_vals = np.zeros((height, width), dtype=np.float32)
    escaped_mask = np.zeros((height, width), dtype=bool)

    for y0 in range(0, height, chunk_rows):
        y1 = min(y0 + chunk_rows, height)
        y_block = ys[y0:y1]
        h_block = y1 - y0
        w = width

        # 构建网格 (h_block, w)
        C_real = np.broadcast_to(xs[None, :], (h_block, w)).copy()
        C_imag = np.broadcast_to(y_block[:, None], (h_block, w)).copy()
        Z_real = np.zeros((h_block, w), dtype=np.float64)
        Z_imag = np.zeros((h_block, w), dtype=np.float64)
        escaped = np.zeros((h_block, w), dtype=bool)
        nu = np.zeros((h_block, w), dtype=np.float64)

        for i in range(max_iter):
            Zr2 = Z_real * Z_real
            Zi2 = Z_imag * Z_imag
            mag2 = Zr2 + Zi2

            not_escaped = ~escaped
            # 当前逃逸
            escape_now = not_escaped & (mag2 > 4.0)
            if escape_now.any():
                mag = np.sqrt(mag2[escape_now])
                with np.errstate(divide='ignore', invalid='ignore'):
                    nu_val = i + 1 - np.log2(np.log(mag + 1e-16))
                nu[escape_now] = nu_val
                escaped[escape_now] = True

            # 继续迭代尚未逃逸且仍在半径内的点
            mask = not_escaped & (mag2 <= 4.0)
            if not mask.any():
                break

            Zi_new = 2.0 * Z_real * Z_imag + C_imag
            Zr_new = Zr2 - Zi2 + C_real
            # 仅更新 mask 区域
            Z_real = np.where(mask, Zr_new, Z_real)
            Z_imag = np.where(mask, Zi_new, Z_imag)

        # 归一化到 [0,1]
        norm = np.zeros_like(nu, dtype=np.float32)
        has_val = escaped & np.isfinite(nu)
        if has_val.any():
            norm[has_val] = np.clip(nu[has_val] / max_iter, 0.0, 1.0).astype(np.float32)

        smooth_vals[y0:y1, :] = norm
        escaped_mask[y0:y1, :] = escaped

    return smooth_vals, escaped_mask


def render_image(width: int, height: int, max_iter: int, viewport: Viewport, palette: str) -> Image.Image:
    smooth, escaped = mandelbrot_escape_smooth(width, height, max_iter, viewport)
    mapper = PALETTES.get(palette, palette_hsv)
    colors = mapper(smooth)
    # 集内点设为黑色
    colors[~escaped] = 0
    return Image.fromarray(colors, mode="RGB")


# -----------------------------
# 交互式查看（Tkinter）
# -----------------------------
class Viewer:
    def __init__(self, width: int, height: int, max_iter: int, viewport: Viewport, palette: str):
        import tkinter as tk

        self.width = width
        self.height = height
        self.max_iter = max_iter
        self.viewport = viewport
        self.palette = palette

        self.tk = tk.Tk()
        self.tk.title(f"Mandelbrot - {palette}")
        self.canvas = tk.Canvas(self.tk, width=width, height=height, highlightthickness=0)
        self.canvas.pack()

        # 拖拽选择框
        self.drag_start: Tuple[int, int] | None = None
        self.rect_id: int | None = None

        self.canvas.bind("<ButtonPress-1>", self.on_press)
        self.canvas.bind("<B1-Motion>", self.on_drag)
        self.canvas.bind("<ButtonRelease-1>", self.on_release)
        self.tk.bind("s", self.on_save)
        self.tk.bind("r", self.on_reset)

        self._imgtk = None  # 持有引用防止被 GC
        self.redraw()

    def redraw(self):
        img = render_image(self.width, self.height, self.max_iter, self.viewport, self.palette)
        from PIL import ImageTk
        self._imgtk = ImageTk.PhotoImage(img)
        self.canvas.create_image(0, 0, anchor="nw", image=self._imgtk)

    def on_press(self, event):
        self.drag_start = (event.x, event.y)
        if self.rect_id is not None:
            self.canvas.delete(self.rect_id)
            self.rect_id = None

    def on_drag(self, event):
        if not self.drag_start:
            return
        x0, y0 = self.drag_start
        x1, y1 = event.x, event.y
        # 维持长宽比
        aspect = self.width / self.height
        dx = x1 - x0
        dy = y1 - y0
        if abs(dx) / max(abs(dy), 1e-6) > aspect:
            # 宽限制
            dy = math.copysign(abs(dx) / aspect, dy if dy != 0 else 1)
            y1 = int(y0 + dy)
        else:
            dx = math.copysign(abs(dy) * aspect, dx if dx != 0 else 1)
            x1 = int(x0 + dx)

        if self.rect_id is not None:
            self.canvas.coords(self.rect_id, x0, y0, x1, y1)
        else:
            self.rect_id = self.canvas.create_rectangle(x0, y0, x1, y1, outline="white")

    def on_release(self, event):
        if not self.drag_start:
            return
        x0, y0 = self.drag_start
        x1, y1 = event.x, event.y
        self.drag_start = None
        if self.rect_id is not None:
            self.canvas.delete(self.rect_id)
            self.rect_id = None

        if abs(x1 - x0) < 3 or abs(y1 - y0) < 3:
            return  # 忽略过小区域

        # 计算新的视图窗口
        aspect = self.width / self.height
        xmin, xmax, ymin, ymax = self.viewport.bounds(aspect)

        x_lo, x_hi = sorted([x0, x1])
        y_lo, y_hi = sorted([y0, y1])

        new_xmin = xmin + (x_lo / self.width) * (xmax - xmin)
        new_xmax = xmin + (x_hi / self.width) * (xmax - xmin)
        new_ymin = ymin + (y_lo / self.height) * (ymax - ymin)
        new_ymax = ymin + (y_hi / self.height) * (ymax - ymin)

        new_center = complex((new_xmin + new_xmax) / 2.0, (new_ymin + new_ymax) / 2.0)
        new_scale = (new_xmax - new_xmin)
        self.viewport = Viewport(center=new_center, scale=new_scale)
        self.redraw()

    def on_save(self, event=None):
        # 保存当前视图为 PNG
        path = f"mandelbrot_{self.width}x{self.height}_{self.palette}.png"
        img = render_image(self.width, self.height, self.max_iter, self.viewport, self.palette)
        img.save(path)
        self.tk.title(f"Saved to {path}")

    def on_reset(self, event=None):
        self.viewport = Viewport()
        self.redraw()

    def run(self):
        self.tk.mainloop()


# -----------------------------
# CLI
# -----------------------------
def parse_center(s: str) -> complex:
    try:
        x_str, y_str = s.split(",")
        return complex(float(x_str), float(y_str))
    except Exception:
        raise argparse.ArgumentTypeError("--center 格式应为 'real,imag' 例如 -0.75,0.0")


def main(argv: list[str] | None = None) -> int:
    p = argparse.ArgumentParser(description="Mandelbrot viewer/renderer")
    p.add_argument("--width", type=int, default=1000, help="图像宽度")
    p.add_argument("--height", type=int, default=700, help="图像高度")
    p.add_argument("--max-iter", type=int, default=512, help="最大迭代次数")
    p.add_argument("--palette", type=str, default="hsv", choices=sorted(PALETTES.keys()), help="调色盘")
    p.add_argument("--center", type=parse_center, default=parse_center("-0.75,0.0"), help="复平面中心 real,imag")
    p.add_argument("--scale", type=float, default=3.5, help="实轴跨度（越小越放大）")
    p.add_argument("--output", type=str, default=None, help="输出 PNG 文件路径（无 GUI）")

    args = p.parse_args(argv)

    viewport = Viewport(center=args.center, scale=args.scale)

    if args.output:
        img = render_image(args.width, args.height, args.max_iter, viewport, args.palette)
        img.save(args.output)
        print(f"Saved: {args.output}")
        return 0
    else:
        viewer = Viewer(args.width, args.height, args.max_iter, viewport, args.palette)
        viewer.run()
        return 0


if __name__ == "__main__":
    raise SystemExit(main())
